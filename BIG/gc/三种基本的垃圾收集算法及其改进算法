基本概念
有向可达图与根集
垃圾收集器将存储器视为一张有向可达图。图中的节点可以分为两组：一组称为根节点，对应于不在堆中的位置，这些位置可以是寄存器、栈中的变量，
或者是虚拟存储器中读写数据区域的全局变量；另外一组称为堆节点，对应于堆中一个分配块；
当存在一个根节点可到达某个堆节点时，我们称该堆节点是可达的，反之称为不可达。不可达堆节点为垃圾。可见垃圾收集的目标即是从从根集出发，
寻找未被引用的堆节点，并将其释放。


三种基本的垃圾收集算法及其改进算法
垃圾收集算法是一个重要而活跃的研究领域，自从20世纪60年代开始对垃圾收集进行研究以来，垃圾算法的研究从未停止。常见的垃圾收集算法有一下这几种类型：
1、引用计数算法（智能指针）
引用技术算法是唯一一种不用用到根集概念的GC算法。其基本思路是为每个对象加一个计数器，计数器记录的是所有指向该对象的引用数量。每次有一个新的引用指向
这个对象时，计数器加一；反之，如果指向该对象的引用被置空或指向其它对象，则计数器减一。当计数器的值为0时，则自动删除这个对象。这个思路可以参考C++ 
引用计数技术及智能指针的简单实现。
引用计数算法的优点是实现简单，在原生不支持GC的语言中也能容易实现出来。另一个优点这种垃圾收集机制是即时回收，也即是对象不再被引用的瞬间就立即被释放掉。
而其缺点是若存在对象的循环引用，无法释放这些对象。
缺点二是多个线程同时对引用计数进行增减时，引用计数的值可能会产生不一致的问题，必须使用并发控制机制解决这一问题，也是一个不小的开销。

2、 Mark & Sweep 算法（unity，c++）
这个算法也称为标记清除算法，为McCarthy独创。它也是目前公认的最有效的GC方案。Mark&Sweep垃圾收集器由标记阶段和回收阶段组成，标记阶段标记出根节点
所有可达的对节点，清除阶段释放每个未被标记的已分配块。典型地，块头部中空闲的低位中的一位用来表示这个块是否已经被标记了。通过Mark&Sweep算法动态
申请内存时，先按需分配内存，当内存不足以分配时，从寄存器或者程序栈上的引用出发，遍历上述的有向可达图并作标记（标记阶段），然后再遍历一次内存空间，
把所有没有标记的对象释放（清除阶段）。因此在收集垃圾时需要中断正常程序，在程序涉及内存大、对象多的时候中断过程可能有点长。当然，收集器也可以作为
一个独立线程不断地定时更新可达图和回收垃圾。该算法不像引用计数可对内存进行即时回收，但是它解决了引用计数的循环引用问题，因此有的语言把引用计数
算法搭配Mark & Sweep 算法构成GC机制。


3、 节点复制算法
Mark & Sweep算法的缺点是在分配大量对象时，且对象大都需要回收时，回收中断过程可能消耗很大。而节点复制算法则刚好相反，当需要回收的对象越多时，
它的开销很小，而当大部分对象都不需要回收时，其开销反而很大。
算法的基本思路是这样的：从根节点开始，被引用的对象都会被复制到一个新的存储区域中，而剩下的对象则是不再被引用的，即为垃圾，留在原来的存储区域。
释放内存时，直接把原来的存储区域释放掉，继续维护新的存储区域即可。过程如图：
可以看到，当被引用对象（非垃圾对象）很多时，需要复制很多的对象到新存储区域。



分代回收
以上三种基本算法各有各的优缺点，也各自有许多改进的方案。通过对这三种方式的融合，出现了一些更加高级的方式。而高级GC技术中最重要的一种为分代回收。
它的基本思路是这样的：程序中存在大量的这样的对象，它们被分配出来之后很快就会被释放，但如果一个对象分配后相当长的一段时间内都没有被回收，
那么极有可能它的生命周期很长，尝试收集它是无用功。为了让GC变得更高效，我们应该对刚诞生不久的对象进行重点扫描，这样就可以回收大部分的垃圾。
为了达到这个目的，我们需要依据对象的”年龄“进行分代，刚刚生成不久的对象划分为新生代，而存在时间长的对象划分为老生代，根据实现方式的不同，可以划分为多个代。
一种回收的实现策略可以是：首先从根开始进行一次常规扫描，扫描过程中如果遇到老生代对象则不进行递归扫描，这样可大大减少扫描次数。这个过程可使用标记清除算法或者复制收集算法。然后，把扫描后残留下来的对象划分到老生代，若是采用标记清除算法，则应该在对象上设置某个标志位标志其年龄；若是采用复制收集，则只需要把新的存储区域内对象设置为老生代就可以了。而实际的实现上，分代回收算法的方案五花八门，常常会融合几种基本算法。

而其他的改进算法数量非常庞大，但大都基于上述的三种基本算法。



原文链接：https://blog.csdn.net/u014550279/article/details/50537761
